---
title: Nonparametric Differential Abundance Testing for Microbiome Counts Data
shorttitle: "DACOMP"
author:
- name: Barak Brill
  affiliation: Department of Statistics and OR, Tel Aviv University
  email: barakbri@mail.tau.ac.il
bibliography: dacomp_bib.bib
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
package: DACOMP
vignette: |
    %\VignetteIndexEntry{Nonparametric differential abundance testing for microbiome counts data}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The DACOMP package implements the methods for detecting differentially abundant taxa in 16S microbiome data across different phenotype levels, as described in Brill et. al. (). microbiome 16S counts data has several unique characteristics, and therefore requires specific methods for statistical inference. More specificly, a sample of 16S counts is a sparse, high dimensional, vector of counts. The sampled counts represent the relative freuqncies of taxa in the sampled ecosystem. However, the total number of counts in a sample is not indicative of the total abundance of taxa in the ecosystem. 

The DACOMP package is aimed at providing valid statistical inference while addressing the above challengs. The key idea is to to first obtain a set of taxa which are non-differentially abundant. These taxa serve as a reference set. In the second step, a fixed number of reads is sampled from each sample from the reads available for the set of reference taxa and the taxon being test. We test whether the number of subsampled counts is indendent from the measured phenotype. If the number of subsampled counts depends on the measured phenotype, the tested taxon alone is responsible for the depndence discovered. For further details, see Brill et al.()

The structure of the vignette is as follows. In section 2 we breifly describe the DACOMP model and underlting assumptions. In section 3 we present the package workflow on example data, containing a set with two study groups. In Sections 4-6 we discuss how to detect differentially abundant taxa in studies with K study groups, paired study design and studies with continoues phenotyes. Section 7 discusses possible extensions and modifications. In Subsection 7.1, we discuss how different methods for selecting reference taxa can be used. In Subsection 7.2, we show how to utilize the DACOMP workflow with other tests of association, supplied by the user. Our example will involve associating differentially abundant taxa with a pair of continous covariates. The user supplied test will be the DCOV test from package ENERGY.

# Model 
Let $\vec{X}$ be a $m$-dimensional vector of counts obtained from a 16S sample. The DACOMP generative model assumes $\vec{X}$ is realized from a multinomial distribution, whose probability vector $\vec{P}$ is a random vector on the unit simplex:

$$ \vec{X} | \vec{P}, N \sim multinom\left( N , \vec{P} \right) ,\quad\quad \vec{P}\sim\mathcal{P}\quad ,0\leq P_{j}, \sum_{j=1}^{m}P_{j} = 1 , $$

where $N$ is the number of counts observed in the sample.

Let $\vec{Y}$ represent the measured vector of phenotypes in a sample. We assume there exists a subset of the taxa, indexed by $\mathcal{B}\subset\{1,2,...,m\}$, that are not differentially abundant. DACOMP assumes ratios between non differentialy abundant taxa are independent of the measured phenotype. For every subset $\{v_1,v_2,...,v_s\} \subset \mathcal{B}$, where $P\left(.. >0\right)=1$, we assume that:


$$\frac{\left(P_{v_1},P_{v_2},...,P_{v_{s}}\right)}{\sum_{k=1}^{s} P_{v_{k}}}\perp \!\!\! \perp \vec{Y}$$
Furthermore, we assume that $P\left(..\right)=1$. Our task is to find all differentially abundant taxa, the complement of the set $\mathcal{B}$.

We show how the $j$th taxon can be tested for differential abundance given a set of reference taxa, $\{b_1,b_2,...,b_r\}\in\mathcal{B}$. The hypothesis of no differential abundance is given by:


$$ H_0^{(j)}:\quad \frac{\left(P_j,P_{b_1},P_{b_2},...,P_{b_{r}}\right)}{P_j + \sum_{k=1}^{r} P_{b_k}}\perp \!\!\! \perp \vec{Y}$$
This hypothesis cannot be tested directly, since \vec{P} is not observed. Brill et al. discuss how this hypothesis can be tested using the observed counts.

Let $\lambda_j$ be the minimal number of reads available in the taxa indexed by $\{j\}\cup\mathcal{B}$ across the different samples. From each sample, select exactly $\lambda_j$ reads, from the reads available under indices $\{j\}\cup\mathcal{B}$. Let $\tilde{X}_j$ denote the number of reads selected from taxon $j$ by rarefaction. Taxon $j$ is tested for differential abundance by testing:


$$\tilde{H}_0^{(j)}: \tilde{X}_{j} \perp \!\!\! \perp \vec{Y}$$

## Choosing reference taxa
In order to obtain a set of reference taxa, we compute the $S_j$ statistic for each taxon $j$.
Let $X_{i,j}$ denote the numeber of counts obtained for taxon $j$ in the $i$th sample. We begin by compuing $SD_{j,k}$, for every pair
$\left(j,k\right) \in \{1,2,...,m\}\otimes\{1,2,...,m\}$:

$$ SD_{j,k} = \mathop{\large{\mathrm{sd}}}^{n}_{i=1}\left(log_{10}\left(\frac{X_{i,j}+1}{X_{i,k}+1}\right)\right)$$

where $n$ is the number of samples, and $sd$ is the sample standard deviation, taken over $n$ samples.

Next, we compute $S_j$ by taking the median over value of $SD_{j,k}$, for fixed $j$:

$$ S_j = \mathop{\large{\mathrm{median}}}^{m}_{k=1, k\ne j}\left({SD}_{j,k}\right)$$

The selected set of reference taxa, $B$, is the set of taxa with $S_j \le S_{crit}$ , with $S_{crit}$ being a predefined threshold:

$$ Select\, B: \quad B = \{j|S_j \leq S_{crit}\}$$
The key assumption for reference selection, is that a small fraction of all taxa are differentially abundant. Hence, a subset of taxa, containing no differentially abundant taxa, can be obtained by selecting a fixed value of $S_{crit}$ as a threshold.

The value of $S_{crit}$ is data specific. In this vignette, we use data from the kostic dataset in the phyloseq package, with $S_{crit} = 0.6$ selected. Other datasets may require different values.

# Workflow
```{r,eval = F}
library(dacomp)

set.seed(1)

data = dacomp.generate_example_dataset.two_sample(m1 = 100,
        n_X = 50,
        n_Y = 50,
        signal_strength_as_change_in_microbial_load = 0.1)
```

## Selecting reference taxa
```{r, eval = F}
#select references: (may take a minute)
result.selected.references = dacomp.select_references(X = data$counts,
                                                    median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                                    verbose = T)

length(result.selected.references$selected_references)

#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)
```

## Testing for differential abundance
```{r, eval = F}
#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.WILCOXON,
                     verbose = T,q = q_DSFDR)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected
```

## Using different non parametric tests

$\verb|DACOMP.TEST.NAME.WILCOXON|$

$\verb|DACOMP.TEST.NAME.LOG_FOLD_DIFFERENCE_IN_MEANS|$

$\verb|DACOMP.TEST.NAME.TWO_PART_WILCOXON|$


```{r, eval = F}
result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.LOG_FOLD_DIFFERENCE_IN_MEANS,
                     verbose = T,q = q_DSFDR)

result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.DIFFERENCE_IN_MEANS,
                     verbose = T,q = q_DSFDR)

result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.TWO_PART_WILCOXON,
                     verbose = T,q = q_DSFDR)
```

# Testing with $K$ sample groups
$\verb|DACOMP.TEST.NAME.KRUSKAL_WALLIS|$

# Testing with paired study design
$\verb|DACOMP.TEST.NAME.WILCOXON_SIGNED_RANK_TEST|$

```{r, eval = F}
set.seed(1)
data = dacomp.generate_example_dataset_paired(30)

#image(t(log10(data$counts+1)),xlab = 'taxa',ylab = 'subject')
#abline(h = 0.5,col = 'black')


data$counts

result.selected.references = dacomp.select_references(X = data$counts,
                                                      median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                                      verbose = T)


length(result.selected.references$selected_references)

#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)


#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts,
                          y = NULL,
                          ind_reference_taxa = result.selected.references,
                          test = DACOMP.TEST.NAME.WILCOXON_SIGNED_RANK_TEST,
                          verbose = T,q = q_DSFDR)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected

sum(rejected_DSFDR %in% data$select_diff_abundant) 
length(rejected_DSFDR)

sum(rejected_BH %in% data$select_diff_abundant) 
length(rejected_BH)
```


# Testing with a continuous covariate
$\verb|DACOMP.TEST.NAME.SPEARMAN|$

```{r,eval = F}
set.seed(1)
data = dacomp.generate_example_dataset_continuous(n = 100,m1 = 30,
signal_strength_as_change_in_microbial_load = 0.1)


result.selected.references = dacomp.select_references(X = data$counts,
                                                      median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                                      verbose = T)
#number of selected references
length(result.selected.references$selected_references)
#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)

#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts,
                          y = data$covariate,test = DACOMP.TEST.NAME.SPEARMAN,
                          ind_reference_taxa = result.selected.references,
                          verbose = T,q = q_DSFDR)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected
 
```


# Extending the procedures provided

## Other reference selection methods
  
## User defined tests

```{r,eval = F}
set.seed(1)

data = dacomp.generate_example_dataset_multivariate_example(n = 100,m1 = 30,signal_strength_as_change_in_microbial_load = 0.1)

#two covariates for each subject
head(data$covariate)
#            u1         u2
#[1,] 0.4820801 0.57487220
#[2,] 0.5995658 0.07706438
#[3,] 0.4935413 0.03554058
#[4,] 0.1862176 0.64279549
#[5,] 0.8273733 0.92861520
#[6,] 0.6684667 0.59809242

result.selected.references = dacomp.select_references(X = data$counts,
                                                      median_SD_threshold = 0.5,
                                                      verbose = T)



#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1


nr_perm_to_perform = 1000

library(energy)
custom_test_function = function(X){
  res = dcov.test(X, data$covariate, R=nr_perm_to_perform)
  return(
          c(
            res$statistic ,
            res$replicates
            )
    )
}

#Perform testing:
result.test = dacomp.test(X = data$counts,
                          y = NULL,
                          test = DACOMP.TEST.NAME.USER_DEFINED,
                          ind_reference_taxa = result.selected.references,
                          verbose = T,q = q_DSFDR,
                          nr_perm = nr_perm_to_perform, # should be exactly the same as the 
                          user_defined_test_function = custom_test_function)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected


```

  