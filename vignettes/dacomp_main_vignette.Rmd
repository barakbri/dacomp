---
title: Nonparametric Differential Abundance Testing for Microbiome Counts Data
shorttitle: "DACOMP"
author:
- name: Barak Brill
  affiliation: Department of Statistics and OR, Tel Aviv University
  email: barakbri@mail.tau.ac.il
- name: Amnon Amir
  affiliation: Sheba Medical Center, Tel Hashomer, affiliated with the Tel Aviv University
- name: Ruth Heller
  affiliation: Department of Statistics and OR, Tel Aviv University
bibliography: dacomp_bib.bib
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
package: DACOMP
vignette: |
    %\VignetteIndexEntry{Nonparametric differential abundance testing for microbiome counts data}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The DACOMP package implements the methods for detecting differentially abundant taxa in 16S microbiome data across different phenotype levels, as described in Brill et. al. (2019) ^[@brill2019testing]. microbiome 16S counts data has several unique characteristics, and therefore requires specific methods for statistical inference. More specificly, a sample of 16S counts is a sparse, high dimensional, vector of counts. The sampled counts represent the relative freuqncies of taxa in the sampled ecosystem. However, the total number of counts in a sample is not indicative of the total abundance of taxa in the ecosystem^[@mandal2015analysis;@gloor2017microbiome;@kumar2018analysis]. 

The DACOMP package is aimed at providing valid statistical inference while addressing the above challengs. The key idea is to to first obtain a set of taxa which are non-differentially abundant. These taxa serve as a reference set. In the second step, a fixed number of reads is sampled from each sample from the reads available for the set of reference taxa and the taxon being test. We test whether the number of subsampled counts is indendent from the measured phenotype. If the number of subsampled counts depends on the measured phenotype, the tested taxon alone is responsible for the depndence discovered. For further details, see Brill et. al.(2019)^[@brill2019testing].

The structure of the vignette is as follows. In section 2 we breifly describe the DACOMP model and underlting assumptions. In section 3 we present the package workflow on example data, containing a set with two study groups. In Sections 4-6 we discuss how to detect differentially abundant taxa in studies with K study groups, paired study design and studies with continoues phenotyes. Section 7 discusses possible extensions and modifications. In Subsection 7.1, we discuss how different methods for selecting reference taxa can be used. In Subsection 7.2, we show how to utilize the DACOMP workflow with other tests of association, supplied by the user. Our example will involve associating differentially abundant taxa with a pair of continous covariates. The user supplied test will be the DCOV test^[@szekely2007measuring] from `R` package `ENERGY`.

You can install the package using the devtools package:
```{r, eval=FALSE}
install.packages("devtools")
devtools::install_github("barakbri/dacomp")
```


# Model 
Let $\vec{X}$ be a $m$-dimensional vector of counts obtained from a 16S sample. The DACOMP generative model assumes $\vec{X}$ is realized from a multinomial distribution, whose probability vector $\vec{P}$ is a random vector on the unit simplex:

$$ \vec{X} | \vec{P}, N \sim multinom\left( N , \vec{P} \right) ,\quad\quad \vec{P}\sim\mathcal{P}\quad ,0\leq P_{j}, \sum_{j=1}^{m}P_{j} = 1 , $$

where $N$ is the number of counts observed in the sample.

Let $\vec{Y}$ represent the measured vector of phenotypes in a sample. We assume there exists a subset of the taxa, indexed by $\mathcal{B}\subset\{1,2,...,m\}$, that are not differentially abundant. DACOMP assumes ratios between non differentialy abundant taxa are independent of the measured phenotype. For every subset $\{v_1,v_2,...,v_s\} \subset \mathcal{B}$, where $P\left(.. >0\right)=1$, we assume that:


$$\frac{\left(P_{v_1},P_{v_2},...,P_{v_{s}}\right)}{\sum_{k=1}^{s} P_{v_{k}}}\perp \!\!\! \perp \vec{Y}$$
Furthermore, we assume that $P\left(..\right)=1$. Our task is to find all differentially abundant taxa, the complement of the set $\mathcal{B}$.

We show how the $j$th taxon can be tested for differential abundance given a set of reference taxa, $\{b_1,b_2,...,b_r\}\in\mathcal{B}$. The hypothesis of no differential abundance is given by:


$$ H_0^{(j)}:\quad \frac{\left(P_j,P_{b_1},P_{b_2},...,P_{b_{r}}\right)}{P_j + \sum_{k=1}^{r} P_{b_k}}\perp \!\!\! \perp \vec{Y}$$
This hypothesis cannot be tested directly, since \vec{P} is not observed. Brill et al. discuss how this hypothesis can be tested using the observed counts.

Let $\lambda_j$ be the minimal number of reads available in the taxa indexed by $\{j\}\cup\mathcal{B}$ across the different samples. From each sample, select exactly $\lambda_j$ reads, from the reads available under indices $\{j\}\cup\mathcal{B}$. Let $\tilde{X}_j$ denote the number of reads selected from taxon $j$ by rarefaction. Taxon $j$ is tested for differential abundance by testing:


$$\tilde{H}_0^{(j)}: \tilde{X}_{j} \perp \!\!\! \perp \vec{Y}$$

The `DACOMP` package provides $P$-values for hypothesis testing. Also, the packge makes use of the $DS-FDR$ method for controlling the False Discvory Rate (FDR)^[@benjamini1995controlling] when multiple hypotheses are tested. The DS-FDR method (Jiang et. al., 2017)^[@jiang2017discrete] is a multiple testing procedure aimed at providing control of the FDR when the null distribution of $P$-values is discrete, and thus stochastically greater then uniform distribution. In this settings, the $DS-FDR$ procedure is known to provide higher power compared to classical multple hypothesis testing procedure, see Jiang et. al. (2017)^[@jiang2017discrete] for further details.

## Choosing reference taxa
In order to obtain a set of reference taxa, we compute the $S_j$ statistic for each taxon $j$.
Let $X_{i,j}$ denote the numeber of counts obtained for taxon $j$ in the $i$th sample. We begin by compuing $SD_{j,k}$, for every pair
$\left(j,k\right) \in \{1,2,...,m\}\otimes\{1,2,...,m\}$:

$$ SD_{j,k} = \mathop{\large{\mathrm{sd}}}^{n}_{i=1}\left(log_{10}\left(\frac{X_{i,j}+1}{X_{i,k}+1}\right)\right)$$

where $n$ is the number of samples, and $sd$ is the sample standard deviation, taken over $n$ samples.

Next, we compute $S_j$ by taking the median over value of $SD_{j,k}$, for fixed $j$:

$$ S_j = \mathop{\large{\mathrm{median}}}^{m}_{k=1, k\ne j}\left({SD}_{j,k}\right)$$

The selected set of reference taxa, $B$, is the set of taxa with $S_j \le S_{crit}$ , with $S_{crit}$ being a predefined threshold:

$$ Select\, B: \quad B = \{j|S_j \leq S_{crit}\}$$
The key assumption for reference selection, is that a small fraction of all taxa are differentially abundant. Hence, a subset of taxa, containing no differentially abundant taxa, can be obtained by selecting a fixed value of $S_{crit}$ as a threshold.

The value of $S_{crit}$ is data specific. In this vignette, we use data from the colorectal cancer dataset^[@kostic2012genomic] in the phyloseq^[@mcmurdie2013phyloseq] package, with $S_{crit} = 0.6$ selected. Other datasets may require different values.

# Workflow
This section demonstrate the workflow for statistical analysis. We begin by generating a sample dataset. The dataset will consist of two study groups (labeled 0 and 1), 50 samples in each study groups. The data will contain 1384 OTUs with `m1=100` OTUs selected (at random) as differentially abundant. The parameter `signal_strength_as_change_in_microbial_load = 0.1` indicates OTUs associated with the phenotype cause a change of 10% in the microbial load, compared to study group 0. Note that this parameter effects the ratios of different columns in the data, but not the total number of counts in a row (sample): the total number of counts in a sample is not indicative of the microbial load.

```{r,eval = F,cache=TRUE}
library(dacomp)

set.seed(1)

data = dacomp.generate_example_dataset.two_sample(m1 = 100,
        n_X = 50,
        n_Y = 50,
        signal_strength_as_change_in_microbial_load = 0.1)
```

The object `data` consists of `data$counts` - a matrix with 100 rows and 1384 columns (per OTU), and `data$group_labels` - a vector of length 100 with values of 0's and 1's, denoting the group labeling of each observation.

## Selecting reference taxa

We begin our analysis by selecting a set of reference taxa. This requires a threshold, $S_{crit}=0.6$
We  also plot the histogram of $S_j$ scores, with vertical lines for the $0.5,0.7,$ and $0.9$ percentiles of $S_j$'s. This allows us to assess how high is $S_{crit}$ compated to the values of $S_j$ in our data.

```{r,eval = F,cache=TRUE}
#select references: (may take a minute)
result.selected.references = dacomp.select_references(
                              X = data$counts,
                              median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                              verbose = F)

length(result.selected.references$selected_references)

#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)
```

## Testing for differential abundance
We test taxa not in the reference set for differential abundance by using the function `dacomp.test`. We show tro possible corrections for multiplicity, based on the BH procedure, and the DS_FDR procedure^[@jiang2017discrete]:

```{r, eval = F}
#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts, #counts data
                     y = data$group_labels, #phenotype in y argument
                     # obtained from dacomp.select_references(...):
                     ind_reference_taxa = result.selected.references, 
                     test = DACOMP.TEST.NAME.WILCOXON, #constant, name of test
                     verbose = F,q = q_DSFDR) #multiplicity adjustment level

#These are the indices of taxa discoverted as differentially abundant:
# by applying a BH multiplicity adjustment on the P-values:
rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH) 
#by applying a DS-FDR multiplicity adjustment on the P-values:
rejected_DSFDR = result.test$dsfdr_rejected 
```

## Using different non parametric tests
The function `dacomp.test(...)` supports several other tests for two study groups:

* `DACOMP.TEST.NAME.DIFFERENCE_IN_MEANS` - Permutation based test for a difference in means

* `DACOMP.TEST.NAME.LOG_FOLD_DIFFERENCE_IN_MEANS` - Permutation based test for a difference in means, after a log transformation. A pseudocount is added to address zeros, before taking the logarithm of the number of subsampled counts.

* `DACOMP.TEST.NAME.TWO_PART_WILCOXON` - A two part test that includes a two-sample test for a change in the proportion of zeros, toghehther with a Wilcoxon rank sum test for detecting a difference in the distribution of the non zero components of $\tilde{X}_{j}$. See Wagner et. al. (2011)^[@wagner2011application] for additional details.


```{r, eval = F}
result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.LOG_FOLD_DIFFERENCE_IN_MEANS,
                     verbose = T,q = q_DSFDR)

result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.DIFFERENCE_IN_MEANS,
                     verbose = T,q = q_DSFDR)

result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.TWO_PART_WILCOXON,
                     verbose = T,q = q_DSFDR)
```

# Testing with $K$ sample groups
The function `dacomp.test` supports the Kruskal Wallis test^[@kruskal1952use] for equality of distributions between K sample groups. The analyze results from a study with a categorical phenotype with $K$ levels, supply as an argument a vector with the group-labeling as a `y` argument, and select `test = DACOMP.TEST.NAME.KRUSKAL_WALLIS`

# Testing with paired study design

To analyze results from a paired study design, with $n$ different samples, each sampled twice, format the data as follows:

 * Generate a matrix of counts, with the first $n$ rows corresponding to samples $1,2,...,n$ under the first condition, and rows $n+1,n+2,...,2n$ corresponding to samples $1,2,...,n$ under the second condition. This matrix is supplied as an argument `X` in `dacomp.test`
 * Use argument `test = DACOMP.TEST.NAME.WILCOXON_SIGNED_RANK_TEST` to select the Wilcoxon sign rank test^[@wilcoxon1945individual].
 * The phenotype argument `y` in `dacomp.test` is set to `NULL`.

An example on how to analyze paired data;

```{r, eval = F}
set.seed(1)
# Sample data:
# 30 is the number of samples, so we will have 60 rows.
# By default, 30 OTUs are differentially abundant
data = dacomp.generate_example_dataset_paired(30) 

# data$counts is matrix of counts:
# first 30 rows correspond to samples 1:30 under condition 1
# rows 31:60 correspond to samples 1:30 under condition 2

#select references:
result.selected.references = dacomp.select_references(
                                X = data$counts,
                                median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                verbose = T)


length(result.selected.references$selected_references)

#plot the reference selection scores:
#(can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)


#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(
                    X = data$counts, #counts matrix formated as required
                    y = NULL, #supply a null phenotype
                    ind_reference_taxa = result.selected.references,
                    test = DACOMP.TEST.NAME.WILCOXON_SIGNED_RANK_TEST,
                    verbose = T,q = q_DSFDR)

#discoveries:
rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected
```


# Testing with a continuous covariate
The function `dacomp.test` allows testing with a continuous phenotype:
* The argument `y` is set to a vector of phenotype measurements by observation.
* The argument `test` is set to `DACOMP.TEST.NAME.SPEARMAN`, the test conducted is a permutation test based on the Spearman correlation coefficient^[@Spearman] between $\tilde{X}_j$ and $Y$.

See a detailed example below.

```{r,eval = F}
set.seed(1)
data = dacomp.generate_example_dataset_continuous(n = 100,m1 = 30,
signal_strength_as_change_in_microbial_load = 0.1)

#data$counts - matrix of counts
#data$covariate - a vector of 100 phenotype measurements,
#corresponding to the rows of X.


result.selected.references = dacomp.select_references(
                                  X = data$counts,
                                  median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                  verbose = T)

#number of selected references
length(result.selected.references$selected_references)

#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)

#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts,
                      y = data$covariate,test = DACOMP.TEST.NAME.SPEARMAN,
                      ind_reference_taxa = result.selected.references,
                      verbose = T,q = q_DSFDR)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected
 
```


# Extending the `dacomp` package
  
## Other reference selection methods
  The argument `ind_reference_taxa` in the function `dacomp.test(...)` can receive one of two possible arguments:
  * Object received from `dacomp.select_references(...)` 
  * A set of integers defining the indices of reference taxa (by columns of the counts matrix).
  
  You can use a general method for selecting a set of reference taxa, and then supply the vector of taxa indices using the argument `ind_reference_taxa`.
  Note that you cannot use phenotypes for reference selection, only for testing.
  
## User defined tests
You can use a general test, to test for association between the rarefied reads, $\tilde{X}_j$ and the phenotype vector $\vec{Y}$. To use a general test, supply the following arguments:

* Set the argument `test` to `DACOMP.TEST.NAME.USER_DEFINED`. This indicates the user is supplying the test.
* Set the argument `y` to `NULL`. If the user supplies a function running the test, the `dacomp` package does not need to access the phenotype data, the user has access to the phenotype data from the function used as an argument.
* set the argument `nr_perm` to the number of permutations performed by the test function supplied (see additional details below)
* Pass a function as an arguemnt , for the argument named `custom_test_function`. The test function receives a vector of rarefied counts as a single argument. The order of rarefied counts is identical to the one provided in the counts matrix. The function must return a single array of test statistics, of length `nr_perm + 1`. The first value of the array is the statistic computed for the original data. The remaining values are test statistics computed for data while permuting the phenotype values between different reads. 

A detailed example is found below. The user defined test is the DCOV test^[@szekely2007measuring] from package `ENERGY`

```{r,eval = F}
set.seed(1)
#generate data, with a multivariate phenotype:

data = dacomp.generate_example_dataset_multivariate_example(
  n = 100,
  m1 = 30,
  signal_strength_as_change_in_microbial_load = 0.1)

#phenotype of dimensionality two, for each subject
head(data$covariate)
#            u1         u2
#[1,] 0.4820801 0.57487220
#[2,] 0.5995658 0.07706438
#[3,] 0.4935413 0.03554058
#[4,] 0.1862176 0.64279549
#[5,] 0.8273733 0.92861520
#[6,] 0.6684667 0.59809242

#select references:
result.selected.references = dacomp.select_references(
                              X = data$counts,
                              median_SD_threshold = 0.5,
                              verbose = T)



#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

# The number of permutations performed for each test.
# Note that this number is passed as an argument to the function, 
# AND must be exactly the number of permutations performed
# and returned by the supplied test function
nr_perm_to_perform = 1000 

# We will use the dcov test from package energy to
# to test for differential abundance

library(energy)

#this is the custom test function supplied by the user
# Input: array of rarefied reads, of length n
# Output: Array of test statistics, with right tailed alternative
# of length nr.perm +1. The first entry is the test statistic for the original data.
custom_test_function = function(X){
  # compute test and permutations. Note that the phenotype
  # is available to the test function
  res = dcov.test(X, data$covariate, R=nr_perm_to_perform)
  return(
          c(
            # first entry is the test statistic to the data:
            res$statistic , 
            # a vector of length nr_perm_to_perform containing
            # test statistics computed for data with permuted
            # phenotypes
            res$replicates
            )
    )
}

#Perform testing:
result.test = dacomp.test(X = data$counts,
                          #note that y is NULL, phenotype is available to the test function:
                          y = NULL, 
                          
                          # set test to be user defined:
                          test = DACOMP.TEST.NAME.USER_DEFINED,
                          ind_reference_taxa = result.selected.references,
                          verbose = T,q = q_DSFDR,
                          
                          #nr_perm must be identical to the number of
                          #permutation returned from test function:
                          nr_perm = nr_perm_to_perform, 
                          
                          #pass as argument the user defined test function:
                          user_defined_test_function = custom_test_function)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected


```

  
  
  
  
  
  
