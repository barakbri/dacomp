---
title: Nonparametric Differential Abundance Testing for Microbiome Counts Data
shorttitle: "DACOMP"
author:
- name: Barak Brill
  affiliation: Department of Statistics and OR, Tel Aviv University
  email: barakbri@mail.tau.ac.il
bibliography: dacomp_bib.bib
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
package: DACOMP
vignette: |
    %\VignetteIndexEntry{Nonparametric differential abundance testing for microbiome counts data}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The DACOMP package implements the methods for detecting differentially abundant taxa in 16S microbiome data across different phenotype levels, as described in Brill et. al. (). microbiome 16S counts data has several unique characteristics, and therefore requires specific methods for statistical inference. More specificly, a sample of 16S counts is a sparse, high dimensional, vector of counts. The sampled counts represent the relative freuqncies of taxa in the sampled ecosystem. However, the total number of counts in a sample is not indicative of the total abundance of taxa in the ecosystem. 

The DACOMP package is aimed at providing valid statistical inference while addressing the above challengs. The key idea is to to first obtain a set of taxa which are non-differentially abundant. These taxa serve as a reference set. In the second step, a fixed number of reads is sampled from each sample from the reads available for the set of reference taxa and the taxon being test. We test whether the number of subsampled counts is indendent from the measured phenotype. If the number of subsampled counts depends on the measured phenotype, the tested taxon alone is responsible for the depndence discovered. For further details, see Brill et al.()

The structure of the vignette is as follows. In section 2 we breifly describe the DACOMP model and underlting assumptions. In section 3 we present the package workflow on example data, containing a set with two study groups. In Sections 4-6 we discuss how to detect differentially abundant taxa in studies with K study groups, paired study design and studies with continoues phenotyes. Section 7 discusses possible extensions and modifications. In Subsection 7.1, we discuss how different methods for selecting reference taxa can be used. In Subsection 7.2, we show how to utilize the DACOMP workflow with other tests of association, supplied by the user. Our example will involve associating differentially abundant taxa with a pair of continous covariates. The user supplied test will be the DCOV test from package ENERGY.

# Model 
Let $\vec{X}$ be a $m$-dimensional vector of counts obtained from a 16S sample. The DACOMP generative model assumes $\vec{X}$ is realized from a multinomial distribution, whose probability vector $\vec{P}$ is a random vector on the unit simplex:

$$ \vec{X} | \vec{P}, N \sim multinom\left( N , \vec{P} \right) ,\quad\quad \vec{P}\sim\mathcal{P}\quad ,0\leq P_{j}, \sum_{j=1}^{m}P_{j} = 1 , $$

where $N$ is the number of counts observed in the sample.

Let $\vec{Y}$ represent the measured vector of phenotypes in a sample. We assume there exists a subset of the taxa, indexed by $\mathcal{B}\subset\{1,2,...,m\}$, that are not differentially abundant. DACOMP assumes ratios between non differentialy abundant taxa are independent of the measured phenotype. For every subset $\{v_1,v_2,...,v_s\} \subset \mathcal{B}$, where $P\left(.. >0\right)=1$, we assume that:


$$\frac{\left(P_{v_1},P_{v_2},...,P_{v_{s}}\right)}{\sum_{k=1}^{s} P_{v_{k}}}\perp \!\!\! \perp \vec{Y}$$
Furthermore, we assume that $P\left(..\right)=1$. Our task is to find all differentially abundant taxa, the complement of the set $\mathcal{B}$.

We show how the $j$th taxon can be tested for differential abundance given a set of reference taxa, $\{b_1,b_2,...,b_r\}\in\mathcal{B}$. The hypothesis of no differential abundance is given by:


$$ H_0^{(j)}:\quad \frac{\left(P_j,P_{b_1},P_{b_2},...,P_{b_{r}}\right)}{P_j + \sum_{k=1}^{r} P_{b_k}}\perp \!\!\! \perp \vec{Y}$$
This hypothesis cannot be tested directly, since \vec{P} is not observed. Brill et al. discuss how this hypothesis can be tested using the observed counts.

Let $\lambda_j$ be the minimal number of reads available in the taxa indexed by $\{j\}\cup\mathcal{B}$ across the different samples. From each sample, select exactly $\lambda_j$ reads, from the reads available under indices $\{j\}\cup\mathcal{B}$. Let $\tilde{X}_j$ denote the number of reads selected from taxon $j$ by rarefaction. Taxon $j$ is tested for differential abundance by testing:


$$\tilde{H}_0^{(j)}: \tilde{X}_{j} \perp \!\!\! \perp \vec{Y}$$

The `DACOMP` package provides $P$-values for hypothesis testing. Also, the packge makes use of the $DS-FDR$ method for controlling the False Discvory Rate (FDR) when multiple hypotheses are tested. The DS-FDR method (Jiang et al. ) is a multiple testing procedure aimed at providing control of the FDR when the null distribution of $P$-values is discrete, and thus stochastically greater then uniform distribution. In this settings, the $DS-FDR$ procedure is known to provide higher power compared to classical multple hypothesis testing procedure, see Jiang et al () for further details.

## Choosing reference taxa
In order to obtain a set of reference taxa, we compute the $S_j$ statistic for each taxon $j$.
Let $X_{i,j}$ denote the numeber of counts obtained for taxon $j$ in the $i$th sample. We begin by compuing $SD_{j,k}$, for every pair
$\left(j,k\right) \in \{1,2,...,m\}\otimes\{1,2,...,m\}$:

$$ SD_{j,k} = \mathop{\large{\mathrm{sd}}}^{n}_{i=1}\left(log_{10}\left(\frac{X_{i,j}+1}{X_{i,k}+1}\right)\right)$$

where $n$ is the number of samples, and $sd$ is the sample standard deviation, taken over $n$ samples.

Next, we compute $S_j$ by taking the median over value of $SD_{j,k}$, for fixed $j$:

$$ S_j = \mathop{\large{\mathrm{median}}}^{m}_{k=1, k\ne j}\left({SD}_{j,k}\right)$$

The selected set of reference taxa, $B$, is the set of taxa with $S_j \le S_{crit}$ , with $S_{crit}$ being a predefined threshold:

$$ Select\, B: \quad B = \{j|S_j \leq S_{crit}\}$$
The key assumption for reference selection, is that a small fraction of all taxa are differentially abundant. Hence, a subset of taxa, containing no differentially abundant taxa, can be obtained by selecting a fixed value of $S_{crit}$ as a threshold.

The value of $S_{crit}$ is data specific. In this vignette, we use data from the kostic dataset in the phyloseq package, with $S_{crit} = 0.6$ selected. Other datasets may require different values.

# Workflow
This section demonstrate the workflow for statistical analysis. We begin by generating a sample dataset. The dataset will consist of two study groups (labeled 0 and 1), 50 samples in each study groups. The data will contain 1384 OTUs with `m1=100` OTUs selected (at random) as differentially abundant. The parameter `signal_strength_as_change_in_microbial_load = 0.1` indicates OTUs associated with the phenotype cause a change of 10% in the microbial load, compared to study group 0. Note that this parameter effects the ratios of different columns in the data, but not the total number of counts in a row (sample): the total number of counts in a sample is not indicative of the microbial load.

```{r,eval = F,cache=TRUE}
library(dacomp)

set.seed(1)

data = dacomp.generate_example_dataset.two_sample(m1 = 100,
        n_X = 50,
        n_Y = 50,
        signal_strength_as_change_in_microbial_load = 0.1)
```

The object `data` consists of `data$counts` - a matrix with 100 rows and 1384 columns (per OTU), and `data$group_labels` - a vector of length 100 with values of 0's and 1's, denoting the group labeling of each observation.

## Selecting reference taxa

We begin our analysis by selecting a set of reference taxa. This requires a threshold, $S_{crit}=0.6$
We  also plot the histogram of $S_j$ scores, with vertical lines for the $0.5,0.7,$ and $0.9$ percentiles of $S_j$'s. This allows us to assess how high is $S_{crit}$ compated to the values of $S_j$ in our data.

```{r,eval = F,cache=TRUE}
#select references: (may take a minute)
result.selected.references = dacomp.select_references(
                              X = data$counts,
                              median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                              verbose = F)

length(result.selected.references$selected_references)

#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)
```

## Testing for differential abundance
We test taxa not in the reference set for differential abundance by using the function `dacomp.test`. We show tro possible corrections for multiplicity, based on the BH procedure, and the DS_FDR procedure:

```{r, eval = F}
#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts, #counts data
                     y = data$group_labels, #phenotype in y argument
                     # obtained from dacomp.select_references(...):
                     ind_reference_taxa = result.selected.references, 
                     test = DACOMP.TEST.NAME.WILCOXON, #constant, name of test
                     verbose = F,q = q_DSFDR) #multiplicity adjustment level

#These are the indices of taxa discoverted as differentially abundant:
# by applying a BH multiplicity adjustment on the P-values:
rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH) 
#by applying a DS-FDR multiplicity adjustment on the P-values:
rejected_DSFDR = result.test$dsfdr_rejected 
```

## Using different non parametric tests
The function `dacomp.test(...)` supports several other tests for two study groups:

* `DACOMP.TEST.NAME.DIFFERENCE_IN_MEANS` - Permutation based test for a difference in means

* `DACOMP.TEST.NAME.LOG_FOLD_DIFFERENCE_IN_MEANS` - Permutation based test for a difference in means, after a log transformation. A pseudocount is added to address zeros, before taking the logarithm of the number of subsampled counts.

* `DACOMP.TEST.NAME.TWO_PART_WILCOXON` - A two part test that includes a two-sample test for a change in the proportion of zeros, toghehther with a Wilcoxon rank sum test for detecting a difference in the distribution of the non zero components of $\tilde{X}_{j}$. See CITATION for additional details.


```{r, eval = F}
result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.LOG_FOLD_DIFFERENCE_IN_MEANS,
                     verbose = T,q = q_DSFDR)

result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.DIFFERENCE_IN_MEANS,
                     verbose = T,q = q_DSFDR)

result.test = dacomp.test(X = data$counts,
                     y = data$group_labels,
                     ind_reference_taxa = result.selected.references,
                     test = DACOMP.TEST.NAME.TWO_PART_WILCOXON,
                     verbose = T,q = q_DSFDR)
```

# Testing with $K$ sample groups
The function `dacomp.test` supports the Kruskal Wallis test for equality of distributions between K sample groups. The analyze results from a study with a categorical phenotype with $K$ levels, supply as an argument a vector with the group-labeling as a `y` argument, and select `test = DACOMP.TEST.NAME.KRUSKAL_WALLIS`

# Testing with paired study design

To analyze results from a paired study design, with $n$ different samples, each sampled twice, format the data as follows:

 * Generate a matrix of counts, with the first $n$ rows corresponding to samples $1,2,...,n$ under the first condition, and rows $n+1,n+2,...,2n$ corresponding to samples $1,2,...,n$ under the second condition. This matrix is supplied as an argument `X` in `dacomp.test`
 * Use argument `test = DACOMP.TEST.NAME.WILCOXON_SIGNED_RANK_TEST` to select the Wilcoxon sign rank test.
 * The phenotype argument `y` in `dacomp.test` is set to `NULL`.

An example on how to analyze paired data;

```{r, eval = F}
set.seed(1)
# Sample data:
# 30 is the number of samples, so we will have 60 rows.
# By default, 30 OTUs are differentially abundant
data = dacomp.generate_example_dataset_paired(30) 

# data$counts is matrix of counts:
# first 30 rows correspond to samples 1:30 under condition 1
# rows 31:60 correspond to samples 1:30 under condition 2

#select references:
result.selected.references = dacomp.select_references(
                                X = data$counts,
                                median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                verbose = T)


length(result.selected.references$selected_references)

#plot the reference selection scores:
#(can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)


#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(
                    X = data$counts, #counts matrix formated as required
                    y = NULL, #supply a null phenotype
                    ind_reference_taxa = result.selected.references,
                    test = DACOMP.TEST.NAME.WILCOXON_SIGNED_RANK_TEST,
                    verbose = T,q = q_DSFDR)

#discoveries:
rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected
```


# Testing with a continuous covariate
The function `dacomp.test` allows testing with a continuous phenotype:
* The argument `y` is set to a vector of phenotype measurements by observation.
* The argument `test` is set to `DACOMP.TEST.NAME.SPEARMAN`, the test conducted is a permutation test based on the Spearman correlation coefficient between $\tilde{X}_j$ and $Y$.

See a detailed example below.

```{r,eval = F}
set.seed(1)
data = dacomp.generate_example_dataset_continuous(n = 100,m1 = 30,
signal_strength_as_change_in_microbial_load = 0.1)

#data$counts - matrix of counts
#data$covariate - a vector of 100 phenotype measurements,
#corresponding to the rows of X.


result.selected.references = dacomp.select_references(
                                  X = data$counts,
                                  median_SD_threshold = 0.6, #APPLICATION SPECIFIC
                                  verbose = T)

#number of selected references
length(result.selected.references$selected_references)

#plot the reference selection scores (can also be used to better set the median SD threshold)
dacomp.plot_reference_scores(result.selected.references)

#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1

#Perform testing:
result.test = dacomp.test(X = data$counts,
                      y = data$covariate,test = DACOMP.TEST.NAME.SPEARMAN,
                      ind_reference_taxa = result.selected.references,
                      verbose = T,q = q_DSFDR)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected
 
```


# Extending the `dacomp` package
  
## Other reference selection methods
  The argument `ind_reference_taxa` in the function `dacomp.test(...)` can receive one of two possible arguments:
  * Object received from `dacomp.select_references(...)` 
  * A set of integers defining the indices of reference taxa (by columns of the counts matrix).
  
  You can use a general method for selecting a set of reference taxa, and then supply the vector of taxa indices using the argument `ind_reference_taxa`.
  Note that you cannot use phenotypes for reference selection, only for testing.
  
## User defined tests
You can use a general test, to test for association between the rarefied reads, $\tilde{X}_j$ and the phenotype vector $\vec{Y}$. To use a general test, supply the following arguments:

*  `DACOMP.TEST.NAME.USER_DEFINED`
* `data$covariate`
* `custom_test_function`
* set the argument `nr_perm`

```{r,eval = F}
set.seed(1)

data = dacomp.generate_example_dataset_multivariate_example(
  n = 100,
  m1 = 30,
  signal_strength_as_change_in_microbial_load = 0.1)

#two covariates for each subject
head(data$covariate)
#            u1         u2
#[1,] 0.4820801 0.57487220
#[2,] 0.5995658 0.07706438
#[3,] 0.4935413 0.03554058
#[4,] 0.1862176 0.64279549
#[5,] 0.8273733 0.92861520
#[6,] 0.6684667 0.59809242

result.selected.references = dacomp.select_references(
                              X = data$counts,
                              median_SD_threshold = 0.5,
                              verbose = T)



#multiplicity correction levels for the BH and DS-FDR methods
q_BH = q_DSFDR = 0.1


nr_perm_to_perform = 1000 # should be exactly the same as the 

library(energy)
custom_test_function = function(X){
  res = dcov.test(X, data$covariate, R=nr_perm_to_perform)
  return(
          c(
            res$statistic ,
            res$replicates
            )
    )
}

#Perform testing:
result.test = dacomp.test(X = data$counts,
                          y = NULL,
                          test = DACOMP.TEST.NAME.USER_DEFINED,
                          ind_reference_taxa = result.selected.references,
                          verbose = T,q = q_DSFDR,
                          nr_perm = nr_perm_to_perform, 
                          user_defined_test_function = custom_test_function)

rejected_BH = which(p.adjust(result.test$p.values.test,method = 'BH')<=q_BH)
rejected_DSFDR = result.test$dsfdr_rejected


```

  